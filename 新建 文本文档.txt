// src/main.rs
mod handlers;
mod models;
mod routes;
mod state;
mod middleware;

// 库模块导入
use tokio::net::TcpListener;
use tracing_subscriber::fmt;
use sqlx::MySqlPool;

// 分离模块导入
use routes::create_routes;
use state::AppState;

#[tokio::main]
async fn main() {
    // 加载.env文件
    dotenv::dotenv().ok();
    let db_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set in .env");

    // 初始化日志
    fmt::init();

    // 创建 MySQL 连接池
    let db_pool = MySqlPool::connect(&db_url)
        .await
        .expect("Failed to create MySQL pool");

    let state = AppState::new(db_pool);

    // 构建路由(注入状态)
    let app = create_routes().with_state(state);

    // 启动服务器
    let listener = TcpListener::bind("0.0.0.0:3000").await.unwrap();
    axum::serve(listener, app).await.unwrap();
}
// src/routes.rs
// 库模块导入
use axum::{routing::{get, post}, Router, middleware};
use tower_http::cors::{CorsLayer, Any};
use axum::http::{Method, HeaderName};

// 分离模块导入
use super::handlers;
use crate::middleware::auth_middleware;
use crate::state::AppState;


// 构建路由并返回 Router 实例
pub fn create_routes() -> Router<AppState> {
    // CORS 中间件
    let cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods(vec![Method::GET, Method::POST])
        .allow_headers(vec![HeaderName::from_static("content-type")]); 

    let public_routes = Router::new()
        .route("/", get(handlers::root))
        .route("/register", post(handlers::register))
        .route("/login", post(handlers::login));
    
    let protected_routes = Router::new() // 被保护的路由
        .route("/protected", get(handlers::protected))
        .route("/chatrooms/create", post(handlers::create_chatroom))
        .route("/chatrooms/join", post(handlers::join_chatroom))
        .route("/chatrooms/leave", post(handlers::leave_chatroom))
        .route_layer(middleware::from_fn(auth_middleware));

    Router::new()
        .merge(public_routes)
        .merge(protected_routes)
        .layer(cors)
}
// src/middleware.rs
use axum::{
    body::Body,
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};
use jsonwebtoken::{decode, DecodingKey, Validation};
use crate::models::Claims;

pub async fn auth_middleware(
    mut request: Request<Body>,
    next: Next,
) -> Result<Response, StatusCode> {
    let token = request.headers()
        .get("Authorization")
        .and_then(|v| v.to_str().ok())
        .and_then(|s| s.strip_prefix("Bearer "));
    
    let token = token.ok_or(StatusCode::UNAUTHORIZED)?;
    
    let token_data = decode::<Claims>(
        token,
        &DecodingKey::from_secret(std::env::var("JWT_SECRET").unwrap().as_ref()),
        &Validation::default()
    ).map_err(|_| StatusCode::UNAUTHORIZED)?;

    request.extensions_mut().insert(token_data.claims);

    Ok(next.run(request).await)
}
// src/state.rs
use sqlx::MySqlPool;

#[derive(Clone)]
pub struct AppState {
    pub db_pool: MySqlPool,
}

impl AppState {
    /// 创建带数据库连接池的应用状态
    pub fn new(db_pool: MySqlPool) -> Self {
        Self { db_pool }
    }
    
    /// 从环境变量初始化（高级用法）
    pub async fn from_env() -> sqlx::Result<Self> {
        let db_url = std::env::var("DATABASE_URL")
            .expect("DATABASE_URL must be set");
        let pool = MySqlPool::connect(&db_url).await?;
        Ok(Self::new(pool))
    }
}
// src/handlers.rs
// 库模块导入
use axum::{
    http::StatusCode,
    Json,
};
use axum::extract::State;
use axum::Extension;
use sqlx::MySqlPool;
use std::error::Error;
use argon2::{
    password_hash::{PasswordHash, PasswordVerifier, SaltString},
    Argon2, PasswordHasher
};
use rand_core::OsRng;
use jsonwebtoken::{encode, EncodingKey, Header};
use std::time::{SystemTime, UNIX_EPOCH};

// 分离模块导入
use crate::{models::{
        RegisterRequest, 
        RegisterResponse,
        LoginRequest, 
        LoginResponse, 
        User,
        Claims
    }, state::AppState};

use crate::models::{CreateChatroomRequest, JoinChatroomRequest, LeaveChatroomRequest, 
                   ChatroomResponse};


// 根路径处理函数
pub async fn root() -> &'static str {
    "Hello, World!"
}

// 注册处理函数
pub async fn register(
    State(state): State<AppState>,// 注入状态
    Json(payload): Json<RegisterRequest>,// 解析为请求结构体
) -> Result<Json<RegisterResponse>, StatusCode> {
    // 生成随机盐值
    let salt = SaltString::generate(&mut OsRng);
    
    // 配置Argon2参数
    let argon2 = Argon2::default();
    
    // 生成密码哈希
    let password_hash = argon2
        .hash_password(payload.password.as_bytes(), &salt)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .to_string();

    // 存储到数据库 (替换原有的明文存储)
    sqlx::query!(
        "INSERT INTO user_info (account, password, username) VALUES (?, ?, ?)",
        payload.account,
        password_hash,
        payload.username,
    )
    .execute(&state.db_pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(RegisterResponse { success: true }))
}

// 登录处理函数
pub async fn login(
    State(state): State<AppState>,
    Json(payload): Json<LoginRequest>,
) -> Result<Json<LoginResponse>, StatusCode> {
    match validate_credentials(&state.db_pool, &payload.account, &payload.password).await {
        Ok(Some(username)) => {
            // 生成JWT令牌
            let token = generate_jwt(&payload.account)
                .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
                
            Ok(Json(LoginResponse {
                username,
                token,
            }))
        }
        Ok(None) => Err(StatusCode::UNAUTHORIZED), // 认证失败， 返回401
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),// 服务器内部错误， 返回500
    }
}

// 登录验证逻辑函数
async fn validate_credentials(
    db_pool: &MySqlPool,
    account: &str,
    password: &str,
) -> Result<Option<String>, Box<dyn Error>> {
    // 从数据库中查询用户信息
    let user = sqlx::query_as::<_, User>(
        "SELECT * FROM user_info WHERE account = ?"
    )
    .bind(account)
    .fetch_optional(db_pool)
    .await?;

    match user {
        Some(user) => {
            // 验证密码哈希
            let parsed_hash = PasswordHash::new(&user.password)
                .map_err(|_| "密码哈希解析失败")?;
                
            let argon2 = Argon2::default();
            match argon2.verify_password(password.as_bytes(), &parsed_hash) {
                Ok(_) => Ok(user.username), // 验证成功
                Err(_) => Ok(None),         // 密码不匹配
            }
        }
        None => Ok(None), // 用户不存在
    }
}

// JWT生成函数
fn generate_jwt(account: &str) -> Result<String, Box<dyn Error>> {
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)?
        .as_secs() as usize;
    
    let exp = now + 3600; // 1小时有效期
    
    let claims = Claims {
        sub: account.to_string(),
        exp,
        iat: now,
    };
    
    let token = encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(std::env::var("JWT_SECRET")?.as_ref())
    )?;
    
    Ok(token)
}

// 保护处理函数
pub async fn protected() -> &'static str {
    "Protected content!"
}


// 创建聊天室
#[axum::debug_handler]
pub async fn create_chatroom(
    Extension(claims): Extension<Claims>,
    State(state): State<AppState>,
    Json(payload): Json<CreateChatroomRequest>,
) -> Result<Json<ChatroomResponse>, StatusCode> {
    let account = claims.sub;

    // 插入聊天室记录
    let result = sqlx::query!(
        "INSERT INTO chatrooms (name, created_by) VALUES (?, ?)",
        payload.name,
        account
    )
    .execute(&state.db_pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    let chatroom_id = result.last_insert_id() as u32;

    // 自动将创建者加入聊天室
    sqlx::query!(
        "INSERT INTO chatroom_members (chatroom_id, account) VALUES (?, ?)",
        chatroom_id,
        account
    )
    .execute(&state.db_pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(ChatroomResponse {
        success: true,
        chatroom_id: Some(chatroom_id),
        message: Some("聊天室创建成功".into()),
    }))
}

// 加入聊天室处理函数
#[axum::debug_handler]
pub async fn join_chatroom(
    Extension(claims): Extension<Claims>,
    State(state): State<AppState>,
    Json(payload): Json<JoinChatroomRequest>,
) -> Result<Json<ChatroomResponse>, StatusCode> {
    let account = claims.sub;
    let chatroom_id = payload.chatroom_id;

    // 检查聊天室是否存在
    let chatroom_exists: Option<i64> = sqlx::query_scalar!(
        "SELECT 1 FROM chatrooms WHERE chatroom_id = ?",
        chatroom_id
    )
    .fetch_optional(&state.db_pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    if chatroom_exists.is_none() {
        return Ok(Json(ChatroomResponse {
            success: false,
            chatroom_id: None,
            message: Some("聊天室不存在".into()),
        }));
    }

    // 检查是否已是成员
    let is_member: Option<i64> = sqlx::query_scalar!(
        "SELECT 1 FROM chatroom_members WHERE chatroom_id = ? AND account = ?",
        chatroom_id,
        account
    )
    .fetch_optional(&state.db_pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    if is_member.is_some() {
        return Ok(Json(ChatroomResponse {
            success: false,
            chatroom_id: Some(chatroom_id),
            message: Some("您已是该聊天室成员".into()),
        }));
    }

    // 加入聊天室
    sqlx::query!(
        "INSERT INTO chatroom_members (chatroom_id, account) VALUES (?, ?)",
        chatroom_id,
        account
    )
    .execute(&state.db_pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(ChatroomResponse {
        success: true,
        chatroom_id: Some(chatroom_id),
        message: Some("成功加入聊天室".into()),
    }))
}

// 退出聊天室处理函数
#[axum::debug_handler]
pub async fn leave_chatroom(
    Extension(claims): Extension<Claims>,
    State(state): State<AppState>,
    Json(payload): Json<LeaveChatroomRequest>,
) -> Result<Json<ChatroomResponse>, StatusCode> {
    let account = claims.sub;
    let chatroom_id = payload.chatroom_id;

    // 退出聊天室
    let result = sqlx::query!(
        "DELETE FROM chatroom_members WHERE chatroom_id = ? AND account = ?",
        chatroom_id,
        account
    )
    .execute(&state.db_pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    if result.rows_affected() == 0 {
        return Ok(Json(ChatroomResponse {
            success: false,
            chatroom_id: Some(chatroom_id),
            message: Some("您不在该聊天室中".into()),
        }));
    }

    Ok(Json(ChatroomResponse {
        success: true,
        chatroom_id: Some(chatroom_id),
        message: Some("已退出聊天室".into()),
    }))
}
// src/models.rs
// 库模块导入
use serde::{Deserialize, Serialize};
use sqlx::FromRow;

// 用户表模型
#[derive(Debug, Deserialize, Serialize, FromRow)]
pub struct User {
    pub account: String,          // 主键 + 非空
    pub password: String,          // 非空
    pub username: Option<String>,  // 允许为空，保留Option
}

// 注册请求结构体
#[derive(Deserialize)]
pub struct RegisterRequest {
    pub account: String,
    pub password: String,
    pub username: String,
}

// 注册响应结构体
#[derive(Serialize)]
pub struct RegisterResponse {
    pub success: bool,
}

// 登录请求模型
#[derive(Deserialize)]
pub struct LoginRequest {
    pub account: String,
    pub password: String,
}

// 登录响应模型
#[derive(Serialize)]
pub struct LoginResponse {
    pub username: String, 
    pub token: String,     // JWT令牌
}

// JWT
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Claims {
    pub sub: String,   // 用户账号
    pub exp: usize,    // 过期时间
    pub iat: usize,    // 签发时间
}

// 聊天室模型
#[derive(Debug, Deserialize, Serialize, FromRow)]
pub struct Chatroom {
    pub chatroom_id: u32,
    pub name: String,
    pub created_by: String, // 创建者账号
    pub created_at: chrono::DateTime<chrono::Utc>,
}

// 聊天室成员模型
#[derive(Debug, Deserialize, Serialize, FromRow)]
pub struct ChatroomMember {
    pub chatroom_id: u32,
    pub account: String,
    pub joined_at: chrono::DateTime<chrono::Utc>,
}

// 创建聊天室请求
#[derive(Deserialize)]
pub struct CreateChatroomRequest {
    pub name: String,
}

// 加入聊天室请求
#[derive(Deserialize)]
pub struct JoinChatroomRequest {
    pub chatroom_id: u32,
}

// 退出聊天室请求
#[derive(Deserialize)]
pub struct LeaveChatroomRequest {
    pub chatroom_id: u32,
}

// 聊天室响应结构
#[derive(Serialize)]
pub struct ChatroomResponse {
    pub success: bool,
    pub chatroom_id: Option<u32>,
    pub message: Option<String>,
}
# src/Cargo.toml

[package]
name = "chat"
version = "0.1.0"
edition = "2024"

[dependencies]
#序列化与反序列化
serde = { version = "1.0", features = ["derive"] }

#axum基于tokio构建
tokio = { version = "1.46", features = ["full"] }

#日志依赖
tracing = "0.1"
tracing-subscriber = "0.3"

#数据库驱动
sqlx = { version = "0.7", features = ["mysql", "runtime-tokio", "tls-native-tls", "macros"] }

#读取环境变量
dotenv = "0.15"

#跨域中间件
tower-http = { version = "0.5.0", features = ["cors"] }
http = "0.2"

#密码哈希
argon2 = "0.5.3"

#用户认证和授权
jsonwebtoken = "9.0"

#随机数
rand_core = { version = "0.6", features = ["std"] }

# 添加chrono时间处理库
chrono = { version = "0.4", features = ["serde"] }

#Axum框架
axum = { version = "0.8.4", features = ["macros"] } 
// sec/.evn